//! Python code generator

use super::{BytecodeChunk, CodeEmitter};
use super::emit::Result;
use nevermind_mir::{MirProgram, MirFunction, MirExpr, MirExprStmt, MirStmt, BinOp, UnaryOp, Literal};

/// Python code generator
pub struct PythonGenerator {
    pub indent_level: usize,
}

impl PythonGenerator {
    pub fn new() -> Self {
        Self {
            indent_level: 0,
        }
    }

    pub fn generate(&self, program: &MirProgram) -> Result<String> {
        let mut generator = PythonGenerator::new();
        let chunk = generator.emit_program(program)?;
        Ok(chunk.code)
    }

    fn indent(&self) -> String {
        " ".repeat(self.indent_level * 4)
    }

    fn output_line(&self, output: &mut BytecodeChunk, text: &str) {
        output.add_line(&format!("{}{}", self.indent(), text));
    }

    fn emit_literal(&self, literal: &Literal) -> String {
        match literal {
            Literal::Int(v) => v.to_string(),
            Literal::Float(v) => v.to_string(),
            Literal::String(v) => format!("\"{}\"", escape_string(v)),
            Literal::Bool(v) => {
                if *v { "True" } else { "False" }.to_string()
            }
            Literal::Null => "None".to_string(),
        }
    }

    fn map_binop(&self, op: BinOp) -> &'static str {
        match op {
            BinOp::Add => "+",
            BinOp::Sub => "-",
            BinOp::Mul => "*",
            BinOp::Div => "/",
            BinOp::Mod => "%",
            BinOp::Pow => "**",
            BinOp::Eq => "==",
            BinOp::Ne => "!=",
            BinOp::Lt => "<",
            BinOp::Le => "<=",
            BinOp::Gt => ">",
            BinOp::Ge => ">=",
            BinOp::And => "and",
            BinOp::Or => "or",
        }
    }

    fn map_unop(&self, op: UnaryOp) -> &'static str {
        match op {
            UnaryOp::Neg => "-",
            UnaryOp::Not => "not ",
        }
    }
}

impl CodeEmitter for PythonGenerator {
    fn emit_program(&mut self, program: &MirProgram) -> Result<BytecodeChunk> {
        let mut output = BytecodeChunk::new();

        // Add Python header comment
        output.add_line("# Generated by Nevermind compiler");

        for stmt in &program.statements {
            match stmt {
                MirStmt::Function { name, params, body, .. } => {
                    // Function definition
                    let params_str: Vec<String> = params.iter().map(|p| p.name.clone()).collect();
                    let params_str = params_str.join(", ");
                    output.add_line(&format!("def {}({}):", name, params_str));

                    // Function body
                    self.indent_level += 1;

                    // Emit statements
                    for stmt in &body.statements {
                        match stmt {
                            MirExprStmt::Let { name, value, .. } => {
                                let expr_chunk = self.emit_expr(value)?;
                                self.output_line(&mut output, &format!("{} = {}", name, expr_chunk.code.trim()));
                            }
                            MirExprStmt::Expr(expr) => {
                                let chunk = self.emit_expr(expr)?;
                                self.output_line(&mut output, chunk.code.trim());
                            }
                            MirExprStmt::Assign { target, value, .. } => {
                                let chunk = self.emit_expr(value)?;
                                self.output_line(&mut output, &format!("{} = {}", target, chunk.code.trim()));
                            }
                            MirExprStmt::Return { value, .. } => {
                                if let Some(v) = value {
                                    let chunk = self.emit_expr(v)?;
                                    self.output_line(&mut output, &format!("return {}", chunk.code.trim()));
                                } else {
                                    self.output_line(&mut output, "return");
                                }
                            }
                        }
                    }

                    // Return expression
                    if let Some(expr) = &body.expr {
                        let chunk = self.emit_expr(expr)?;
                        self.output_line(&mut output, &format!("return {}", chunk.code.trim()));
                    } else {
                        self.output_line(&mut output, "return None");
                    }

                    self.indent_level -= 1;
                    output.add_line("");
                }
                MirStmt::Let { name, value, .. } => {
                    let expr_chunk = self.emit_expr(value)?;
                    output.add_line(&format!("{} = {}", name, expr_chunk.code.trim()));
                }
                MirStmt::Expr(expr) => {
                    let chunk = self.emit_expr(expr)?;
                    output.add_line(chunk.code.trim());
                }
            }
        }

        Ok(output)
    }

    fn emit_function(&mut self, func: &MirFunction) -> Result<BytecodeChunk> {
        let mut output = BytecodeChunk::new();

        // Function definition
        let params: Vec<String> = func.params.iter().map(|p| p.name.clone()).collect();
        let params_str = params.join(", ");
        output.add_line(&format!("def {}({}):", func.name, params_str));

        // Function body
        self.indent_level += 1;

        // Emit statements
        for stmt in &func.body.statements {
            match stmt {
                MirExprStmt::Let { name, value, .. } => {
                    let expr_chunk = self.emit_expr(value)?;
                    self.output_line(&mut output, &format!("{} = {}", name, expr_chunk.code.trim()));
                }
                MirExprStmt::Expr(expr) => {
                    let chunk = self.emit_expr(expr)?;
                    self.output_line(&mut output, chunk.code.trim());
                }
                MirExprStmt::Assign { target, value, .. } => {
                    let chunk = self.emit_expr(value)?;
                    self.output_line(&mut output, &format!("{} = {}", target, chunk.code.trim()));
                }
                MirExprStmt::Return { value, .. } => {
                    if let Some(v) = value {
                        let chunk = self.emit_expr(v)?;
                        self.output_line(&mut output, &format!("return {}", chunk.code.trim()));
                    } else {
                        self.output_line(&mut output, "return");
                    }
                }
            }
        }

        // Return expression
        if let Some(expr) = &func.body.expr {
            let chunk = self.emit_expr(expr)?;
            self.output_line(&mut output, &format!("return {}", chunk.code.trim()));
        } else {
            self.output_line(&mut output, "return None");
        }

        self.indent_level -= 1;

        output.add_line("");

        Ok(output)
    }

    fn emit_expr(&mut self, expr: &MirExpr) -> Result<BytecodeChunk> {
        let mut output = BytecodeChunk::new();

        match expr {
            MirExpr::Literal { value, .. } => {
                output.add_line(&self.emit_literal(value));
            }

            MirExpr::Variable { name, .. } => {
                output.add_line(name);
            }

            MirExpr::Binary { op, left, right, .. } => {
                let left_chunk = self.emit_expr(left)?;
                let right_chunk = self.emit_expr(right)?;
                let py_op = self.map_binop(*op);

                output.add_line(&format!("({} {} {})",
                    left_chunk.code.trim(),
                    py_op,
                    right_chunk.code.trim()
                ));
            }

            MirExpr::Unary { op, operand, .. } => {
                let operand_chunk = self.emit_expr(operand)?;
                let py_op = self.map_unop(*op);

                output.add_line(&format!("{}{}", py_op, operand_chunk.code.trim()));
            }

            MirExpr::Call { callee, args, .. } => {
                let callee_chunk = self.emit_expr(callee)?;
                let mut arg_strings = Vec::new();

                for arg in args {
                    let chunk = self.emit_expr(arg)?;
                    arg_strings.push(chunk.code.trim().to_string());
                }

                output.add_line(&format!("{}({})", callee_chunk.code.trim(), arg_strings.join(", ")));
            }

            MirExpr::Block { statements, expr, .. } => {
                // Emit statements
                for stmt in statements {
                    match stmt {
                        MirExprStmt::Let { name, value, .. } => {
                            let value_chunk = self.emit_expr(value)?;
                            output.add_line(&format!("{} = {}", name, value_chunk.code.trim()));
                        }
                        MirExprStmt::Expr(e) => {
                            let chunk = self.emit_expr(e)?;
                            output.code.push_str(chunk.code.trim());
                            output.code.push_str("\n");
                        }
                        MirExprStmt::Assign { target, value, .. } => {
                            let chunk = self.emit_expr(value)?;
                            output.add_line(&format!("{} = {}", target, chunk.code.trim()));
                        }
                        MirExprStmt::Return { value, .. } => {
                            if let Some(v) = value {
                                let chunk = self.emit_expr(v)?;
                                output.add_line(&format!("return {}", chunk.code.trim()));
                            } else {
                                output.add_line("return");
                            }
                        }
                    }
                }

                // Final expression
                if let Some(e) = expr {
                    let chunk = self.emit_expr(e)?;
                    output.add_line(chunk.code.trim());
                }
            }

            MirExpr::List { elements, .. } => {
                let mut element_strings = Vec::new();
                for elem in elements {
                    let chunk = self.emit_expr(elem)?;
                    element_strings.push(chunk.code.trim().to_string());
                }
                output.add_line(&format!("[{}]", element_strings.join(", ")));
            }

            MirExpr::If { condition, then_branch, else_branch, .. } => {
                let cond_chunk = self.emit_expr(condition)?;
                let then_chunk = self.emit_expr(then_branch)?;
                let else_chunk = self.emit_expr(else_branch)?;

                output.add_line(&format!("({} if {} else {})",
                    then_chunk.code.trim(),
                    cond_chunk.code.trim(),
                    else_chunk.code.trim()
                ));
            }

            MirExpr::Index { array, index, .. } => {
                let array_chunk = self.emit_expr(array)?;
                let index_chunk = self.emit_expr(index)?;

                output.add_line(&format!("{}[{}]",
                    array_chunk.code.trim(),
                    index_chunk.code.trim()
                ));
            }
        }

        Ok(output)
    }
}

/// Escape a string literal for Python
fn escape_string(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}